{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { getEndpointFromRegion } from \"./utils/getEndpointFromRegion\";\nimport { normalizeEndpoint } from \"./utils/normalizeEndpoint\";\nexport var resolveEndpointsConfig = function (input) {\n  var _a;\n\n  return __assign(__assign({}, input), {\n    tls: (_a = input.tls) !== null && _a !== void 0 ? _a : true,\n    endpoint: input.endpoint ? normalizeEndpoint(__assign(__assign({}, input), {\n      endpoint: input.endpoint\n    })) : function () {\n      return getEndpointFromRegion(input);\n    },\n    isCustomEndpoint: input.endpoint ? true : false\n  });\n};","map":{"version":3,"mappings":";AAEA,SAASA,qBAAT,QAAsC,+BAAtC;AACA,SAASC,iBAAT,QAAkC,2BAAlC;AAiCA,OAAO,IAAMC,sBAAsB,GAAG,UACpCC,KADoC,EACgB;;;EACpB,6BAC7BA,KAD6B,GACxB;IACRC,GAAG,EAAE,WAAK,CAACA,GAAN,MAAS,IAAT,IAASC,aAAT,GAASA,EAAT,GAAa,IADV;IAERC,QAAQ,EAAEH,KAAK,CAACG,QAAN,GACNL,iBAAiB,uBAAME,KAAN,GAAW;MAAEG,QAAQ,EAAEH,KAAK,CAACG;IAAlB,CAAX,EADX,GAEN;MAAM,4BAAqB,CAACH,KAAD,CAArB;IAA4B,CAJ9B;IAKRI,gBAAgB,EAAEJ,KAAK,CAACG,QAAN,GAAiB,IAAjB,GAAwB;EALlC,CADwB;AAOhC,CATK","names":["getEndpointFromRegion","normalizeEndpoint","resolveEndpointsConfig","input","tls","_a","endpoint","isCustomEndpoint"],"sources":["/Users/dylanbienstock/Documents/cs98/hack-a-thing-1/amplifyapp/node_modules/@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/config-resolver/src/endpointsConfig/resolveEndpointsConfig.ts"],"sourcesContent":["import { Endpoint, Provider, RegionInfoProvider, UrlParser } from \"@aws-sdk/types\";\n\nimport { getEndpointFromRegion } from \"./utils/getEndpointFromRegion\";\nimport { normalizeEndpoint } from \"./utils/normalizeEndpoint\";\n\nexport interface EndpointsInputConfig {\n  /**\n   * The fully qualified endpoint of the webservice. This is only required when using a custom endpoint (for example, when using a local version of S3).\n   */\n  endpoint?: string | Endpoint | Provider<Endpoint>;\n\n  /**\n   * Whether TLS is enabled for requests.\n   */\n  tls?: boolean;\n}\n\ninterface PreviouslyResolved {\n  regionInfoProvider: RegionInfoProvider;\n  urlParser: UrlParser;\n  region: Provider<string>;\n}\n\nexport interface EndpointsResolvedConfig extends Required<EndpointsInputConfig> {\n  /**\n   * Resolved value for input {@link EndpointsResolvedConfig.endpoint}\n   */\n  endpoint: Provider<Endpoint>;\n\n  /**\n   * Whether the endpoint is specified by caller.\n   * @internal\n   */\n  isCustomEndpoint: boolean;\n}\n\nexport const resolveEndpointsConfig = <T>(\n  input: T & EndpointsInputConfig & PreviouslyResolved\n): T & EndpointsResolvedConfig => ({\n  ...input,\n  tls: input.tls ?? true,\n  endpoint: input.endpoint\n    ? normalizeEndpoint({ ...input, endpoint: input.endpoint })\n    : () => getEndpointFromRegion(input),\n  isCustomEndpoint: input.endpoint ? true : false,\n});\n"]},"metadata":{},"sourceType":"module"}