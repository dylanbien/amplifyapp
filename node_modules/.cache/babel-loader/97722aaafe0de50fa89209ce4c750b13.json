{"ast":null,"code":"import { strictParseByte, strictParseDouble, strictParseFloat32, strictParseShort } from \"./parse-utils\"; // Build indexes outside so we allocate them once.\n\nvar DAYS = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"]; // These must be kept in order\n// prettier-ignore\n\nvar MONTHS = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n/**\n * Builds a proper UTC HttpDate timestamp from a Date object\n * since not all environments will have this as the expected\n * format.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toUTCString\n * > Prior to ECMAScript 2018, the format of the return value\n * > varied according to the platform. The most common return\n * > value was an RFC-1123 formatted date stamp, which is a\n * > slightly updated version of RFC-822 date stamps.\n */\n\nexport function dateToUtcString(date) {\n  var year = date.getUTCFullYear();\n  var month = date.getUTCMonth();\n  var dayOfWeek = date.getUTCDay();\n  var dayOfMonthInt = date.getUTCDate();\n  var hoursInt = date.getUTCHours();\n  var minutesInt = date.getUTCMinutes();\n  var secondsInt = date.getUTCSeconds(); // Build 0 prefixed strings for contents that need to be\n  // two digits and where we get an integer back.\n\n  var dayOfMonthString = dayOfMonthInt < 10 ? \"0\" + dayOfMonthInt : \"\" + dayOfMonthInt;\n  var hoursString = hoursInt < 10 ? \"0\" + hoursInt : \"\" + hoursInt;\n  var minutesString = minutesInt < 10 ? \"0\" + minutesInt : \"\" + minutesInt;\n  var secondsString = secondsInt < 10 ? \"0\" + secondsInt : \"\" + secondsInt;\n  return DAYS[dayOfWeek] + \", \" + dayOfMonthString + \" \" + MONTHS[month] + \" \" + year + \" \" + hoursString + \":\" + minutesString + \":\" + secondsString + \" GMT\";\n}\nvar RFC3339 = new RegExp(/^(?<Y>\\d{4})-(?<M>\\d{2})-(?<D>\\d{2})[tT](?<H>\\d{2}):(?<m>\\d{2}):(?<s>\\d{2})(?:\\.(?<frac>\\d+))?[zZ]$/);\n/**\n * Parses a value into a Date. Returns undefined if the input is null or\n * undefined, throws an error if the input is not a string that can be parsed\n * as an RFC 3339 date.\n *\n * Input strings must conform to RFC3339 section 5.6, and cannot have a UTC\n * offset. Fractional precision is supported.\n *\n * {@see https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14}\n *\n * @param value the value to parse\n * @return a Date or undefined\n */\n\nexport var parseRfc3339DateTime = function (value) {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n\n  if (typeof value !== \"string\") {\n    throw new TypeError(\"RFC-3339 date-times must be expressed as strings\");\n  }\n\n  var match = RFC3339.exec(value);\n\n  if (!match || !match.groups) {\n    throw new TypeError(\"Invalid RFC-3339 date-time value\");\n  }\n\n  var year = strictParseShort(stripLeadingZeroes(match.groups[\"Y\"]));\n  var month = parseDateValue(match.groups[\"M\"], \"month\", 1, 12);\n  var day = parseDateValue(match.groups[\"D\"], \"day\", 1, 31);\n  return buildDate(year, month, day, match);\n};\nvar IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (?<D>\\d{2}) (?<M>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (?<Y>\\d{4}) (?<H>\\d{2}):(?<m>\\d{2}):(?<s>\\d{2})(?:\\.(?<frac>\\d+))? GMT$/);\nvar RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (?<D>\\d{2})-(?<M>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(?<Y>\\d{2}) (?<H>\\d{2}):(?<m>\\d{2}):(?<s>\\d{2})(?:\\.(?<frac>\\d+))? GMT$/);\nvar ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (?<M>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (?<D> [1-9]|\\d{2}) (?<H>\\d{2}):(?<m>\\d{2}):(?<s>\\d{2})(?:\\.(?<frac>\\d+))? (?<Y>\\d{4})$/);\n/**\n * Parses a value into a Date. Returns undefined if the input is null or\n * undefined, throws an error if the input is not a string that can be parsed\n * as an RFC 7231 IMF-fixdate or obs-date.\n *\n * Input strings must conform to RFC7231 section 7.1.1.1. Fractional seconds are supported.\n *\n * {@see https://datatracker.ietf.org/doc/html/rfc7231.html#section-7.1.1.1}\n *\n * @param value the value to parse\n * @return a Date or undefined\n */\n\nexport var parseRfc7231DateTime = function (value) {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n\n  if (typeof value !== \"string\") {\n    throw new TypeError(\"RFC-7231 date-times must be expressed as strings\");\n  } //allow customization of day parsing for asctime days, which can be left-padded with spaces\n\n\n  var dayFn = function (value) {\n    return parseDateValue(value, \"day\", 1, 31);\n  }; //all formats other than RFC 850 use a four-digit year\n\n\n  var yearFn = function (value) {\n    return strictParseShort(stripLeadingZeroes(value));\n  }; //RFC 850 dates need post-processing to adjust year values if they are too far in the future\n\n\n  var dateAdjustmentFn = function (value) {\n    return value;\n  };\n\n  var match = IMF_FIXDATE.exec(value);\n\n  if (!match || !match.groups) {\n    match = RFC_850_DATE.exec(value);\n\n    if (match && match.groups) {\n      // RFC 850 dates use 2-digit years. So we parse the year specifically,\n      // and then once we've constructed the entire date, we adjust it if the resultant date\n      // is too far in the future.\n      yearFn = parseTwoDigitYear;\n      dateAdjustmentFn = adjustRfc850Year;\n    } else {\n      match = ASC_TIME.exec(value);\n\n      if (match && match.groups) {\n        dayFn = function (value) {\n          return parseDateValue(value.trimLeft(), \"day\", 1, 31);\n        };\n      } else {\n        throw new TypeError(\"Invalid RFC-7231 date-time value\");\n      }\n    }\n  }\n\n  var year = yearFn(match.groups[\"Y\"]);\n  var month = parseMonthByShortName(match.groups[\"M\"]);\n  var day = dayFn(match.groups[\"D\"]);\n  return dateAdjustmentFn(buildDate(year, month, day, match));\n};\n/**\n * Parses a value into a Date. Returns undefined if the input is null or\n * undefined, throws an error if the input is not a number or a parseable string.\n *\n * Input strings must be an integer or floating point number. Fractional seconds are supported.\n *\n * @param value the value to parse\n * @return a Date or undefined\n */\n\nexport var parseEpochTimestamp = function (value) {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n\n  var valueAsDouble;\n\n  if (typeof value === \"number\") {\n    valueAsDouble = value;\n  } else if (typeof value === \"string\") {\n    valueAsDouble = strictParseDouble(value);\n  } else {\n    throw new TypeError(\"Epoch timestamps must be expressed as floating point numbers or their string representation\");\n  }\n\n  if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {\n    throw new TypeError(\"Epoch timestamps must be valid, non-Infinite, non-NaN numerics\");\n  }\n\n  return new Date(Math.round(valueAsDouble * 1000));\n};\n/**\n * Build a date from a numeric year, month, date, and an match with named groups\n * \"H\", \"m\", s\", and \"frac\", representing hours, minutes, seconds, and optional fractional seconds.\n * @param year numeric year\n * @param month numeric month, 1-indexed\n * @param day numeric year\n * @param match match with groups \"H\", \"m\", s\", and \"frac\"\n */\n\nvar buildDate = function (year, month, day, match) {\n  var adjustedMonth = month - 1; // JavaScript, and our internal data structures, expect 0-indexed months\n\n  validateDayOfMonth(year, adjustedMonth, day); // Adjust month down by 1\n\n  return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(match.groups[\"H\"], \"hour\", 0, 23), parseDateValue(match.groups[\"m\"], \"minute\", 0, 59), // seconds can go up to 60 for leap seconds\n  parseDateValue(match.groups[\"s\"], \"seconds\", 0, 60), parseMilliseconds(match.groups[\"frac\"])));\n};\n/**\n * RFC 850 dates use a 2-digit year; start with the assumption that if it doesn't\n * match the current year, then it's a date in the future, then let adjustRfc850Year adjust\n * the final date back to the past if it's too far in the future.\n *\n * Example: in 2021, start with the assumption that '11' is '2111', and that '22' is '2022'.\n * adjustRfc850Year will adjust '11' to 2011, (as 2111 is more than 50 years in the future),\n * but keep '22' as 2022. in 2099, '11' will represent '2111', but '98' should be '2098'.\n * There's no description of an RFC 850 date being considered too far in the past in RFC-7231,\n * so it's entirely possible that 2011 is a valid interpretation of '11' in 2099.\n * @param value the 2 digit year to parse\n * @return number a year that is equal to or greater than the current UTC year\n */\n\n\nvar parseTwoDigitYear = function (value) {\n  var thisYear = new Date().getUTCFullYear();\n  var valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));\n\n  if (valueInThisCentury < thisYear) {\n    // This may end up returning a year that adjustRfc850Year turns back by 100.\n    // That's fine! We don't know the other components of the date yet, so there are\n    // boundary conditions that only adjustRfc850Year can handle.\n    return valueInThisCentury + 100;\n  }\n\n  return valueInThisCentury;\n};\n\nvar FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1000;\n/**\n * Adjusts the year value found in RFC 850 dates according to the rules\n * expressed in RFC7231, which state:\n *\n * <blockquote>Recipients of a timestamp value in rfc850-date format, which uses a\n * two-digit year, MUST interpret a timestamp that appears to be more\n * than 50 years in the future as representing the most recent year in\n * the past that had the same last two digits.</blockquote>\n *\n * @param input a Date that assumes the two-digit year was in the future\n * @return a Date that is in the past if input is > 50 years in the future\n */\n\nvar adjustRfc850Year = function (input) {\n  if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {\n    return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));\n  }\n\n  return input;\n};\n\nvar parseMonthByShortName = function (value) {\n  var monthIdx = MONTHS.indexOf(value);\n\n  if (monthIdx < 0) {\n    throw new TypeError(\"Invalid month: \" + value);\n  }\n\n  return monthIdx + 1;\n};\n\nvar DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n/**\n * Validate the day is valid for the given month.\n * @param year the year\n * @param month the month (0-indexed)\n * @param day the day of the month\n */\n\nvar validateDayOfMonth = function (year, month, day) {\n  var maxDays = DAYS_IN_MONTH[month];\n\n  if (month === 1 && isLeapYear(year)) {\n    maxDays = 29;\n  }\n\n  if (day > maxDays) {\n    throw new TypeError(\"Invalid day for \" + MONTHS[month] + \" in \" + year + \": \" + day);\n  }\n};\n\nvar isLeapYear = function (year) {\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n};\n\nvar parseDateValue = function (value, type, lower, upper) {\n  var dateVal = strictParseByte(stripLeadingZeroes(value));\n\n  if (dateVal < lower || dateVal > upper) {\n    throw new TypeError(type + \" must be between \" + lower + \" and \" + upper + \", inclusive\");\n  }\n\n  return dateVal;\n};\n\nvar parseMilliseconds = function (value) {\n  if (value === null || value === undefined) {\n    return 0;\n  }\n\n  return strictParseFloat32(\"0.\" + value) * 1000;\n};\n\nvar stripLeadingZeroes = function (value) {\n  var idx = 0;\n\n  while (idx < value.length - 1 && value.charAt(idx) === \"0\") {\n    idx++;\n  }\n\n  if (idx === 0) {\n    return value;\n  }\n\n  return value.slice(idx);\n};","map":{"version":3,"mappings":"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","names":["strictParseByte","strictParseDouble","strictParseFloat32","strictParseShort","DAYS","MONTHS","dateToUtcString","date","year","getUTCFullYear","month","getUTCMonth","dayOfWeek","getUTCDay","dayOfMonthInt","getUTCDate","hoursInt","getUTCHours","minutesInt","getUTCMinutes","secondsInt","getUTCSeconds","dayOfMonthString","hoursString","minutesString","secondsString","RFC3339","RegExp","parseRfc3339DateTime","value","undefined","TypeError","match","exec","groups","stripLeadingZeroes","parseDateValue","day","buildDate","IMF_FIXDATE","RFC_850_DATE","ASC_TIME","parseRfc7231DateTime","dayFn","yearFn","dateAdjustmentFn","parseTwoDigitYear","adjustRfc850Year","trimLeft","parseMonthByShortName","parseEpochTimestamp","valueAsDouble","Number","isNaN","Infinity","Date","Math","round","adjustedMonth","validateDayOfMonth","UTC","parseMilliseconds","thisYear","valueInThisCentury","floor","FIFTY_YEARS_IN_MILLIS","input","getTime","getUTCMilliseconds","monthIdx","indexOf","DAYS_IN_MONTH","maxDays","isLeapYear","type","lower","upper","dateVal","idx","length","charAt","slice"],"sources":["/Users/dylanbienstock/Documents/cs98/hack-a-thing-1/amplifyapp/node_modules/@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/smithy-client/src/date-utils.ts"],"sourcesContent":["import { strictParseByte, strictParseDouble, strictParseFloat32, strictParseShort } from \"./parse-utils\";\n\n// Build indexes outside so we allocate them once.\nconst DAYS: Array<String> = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n\n// These must be kept in order\n// prettier-ignore\nconst MONTHS: Array<String> = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n/**\n * Builds a proper UTC HttpDate timestamp from a Date object\n * since not all environments will have this as the expected\n * format.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toUTCString\n * > Prior to ECMAScript 2018, the format of the return value\n * > varied according to the platform. The most common return\n * > value was an RFC-1123 formatted date stamp, which is a\n * > slightly updated version of RFC-822 date stamps.\n */\nexport function dateToUtcString(date: Date): string {\n  const year = date.getUTCFullYear();\n  const month = date.getUTCMonth();\n  const dayOfWeek = date.getUTCDay();\n  const dayOfMonthInt = date.getUTCDate();\n  const hoursInt = date.getUTCHours();\n  const minutesInt = date.getUTCMinutes();\n  const secondsInt = date.getUTCSeconds();\n\n  // Build 0 prefixed strings for contents that need to be\n  // two digits and where we get an integer back.\n  const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;\n  const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;\n  const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;\n  const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;\n\n  return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;\n}\n\nconst RFC3339 = new RegExp(\n  /^(?<Y>\\d{4})-(?<M>\\d{2})-(?<D>\\d{2})[tT](?<H>\\d{2}):(?<m>\\d{2}):(?<s>\\d{2})(?:\\.(?<frac>\\d+))?[zZ]$/\n);\n\n/**\n * Parses a value into a Date. Returns undefined if the input is null or\n * undefined, throws an error if the input is not a string that can be parsed\n * as an RFC 3339 date.\n *\n * Input strings must conform to RFC3339 section 5.6, and cannot have a UTC\n * offset. Fractional precision is supported.\n *\n * {@see https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14}\n *\n * @param value the value to parse\n * @return a Date or undefined\n */\nexport const parseRfc3339DateTime = (value: unknown): Date | undefined => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (typeof value !== \"string\") {\n    throw new TypeError(\"RFC-3339 date-times must be expressed as strings\");\n  }\n  const match = RFC3339.exec(value);\n  if (!match || !match.groups) {\n    throw new TypeError(\"Invalid RFC-3339 date-time value\");\n  }\n  const year = strictParseShort(stripLeadingZeroes(match.groups[\"Y\"]))!;\n  const month = parseDateValue(match.groups[\"M\"], \"month\", 1, 12);\n  const day = parseDateValue(match.groups[\"D\"], \"day\", 1, 31);\n\n  return buildDate(year, month, day, match);\n};\n\nconst IMF_FIXDATE = new RegExp(\n  /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (?<D>\\d{2}) (?<M>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (?<Y>\\d{4}) (?<H>\\d{2}):(?<m>\\d{2}):(?<s>\\d{2})(?:\\.(?<frac>\\d+))? GMT$/\n);\nconst RFC_850_DATE = new RegExp(\n  /^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (?<D>\\d{2})-(?<M>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(?<Y>\\d{2}) (?<H>\\d{2}):(?<m>\\d{2}):(?<s>\\d{2})(?:\\.(?<frac>\\d+))? GMT$/\n);\nconst ASC_TIME = new RegExp(\n  /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (?<M>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (?<D> [1-9]|\\d{2}) (?<H>\\d{2}):(?<m>\\d{2}):(?<s>\\d{2})(?:\\.(?<frac>\\d+))? (?<Y>\\d{4})$/\n);\n\n/**\n * Parses a value into a Date. Returns undefined if the input is null or\n * undefined, throws an error if the input is not a string that can be parsed\n * as an RFC 7231 IMF-fixdate or obs-date.\n *\n * Input strings must conform to RFC7231 section 7.1.1.1. Fractional seconds are supported.\n *\n * {@see https://datatracker.ietf.org/doc/html/rfc7231.html#section-7.1.1.1}\n *\n * @param value the value to parse\n * @return a Date or undefined\n */\nexport const parseRfc7231DateTime = (value: unknown): Date | undefined => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (typeof value !== \"string\") {\n    throw new TypeError(\"RFC-7231 date-times must be expressed as strings\");\n  }\n\n  //allow customization of day parsing for asctime days, which can be left-padded with spaces\n  let dayFn: (value: string) => number = (value) => parseDateValue(value, \"day\", 1, 31);\n\n  //all formats other than RFC 850 use a four-digit year\n  let yearFn: (value: string) => number = (value: string) => strictParseShort(stripLeadingZeroes(value))!;\n  //RFC 850 dates need post-processing to adjust year values if they are too far in the future\n  let dateAdjustmentFn: (value: Date) => Date = (value) => value;\n\n  let match = IMF_FIXDATE.exec(value);\n  if (!match || !match.groups) {\n    match = RFC_850_DATE.exec(value);\n    if (match && match.groups) {\n      // RFC 850 dates use 2-digit years. So we parse the year specifically,\n      // and then once we've constructed the entire date, we adjust it if the resultant date\n      // is too far in the future.\n      yearFn = parseTwoDigitYear;\n      dateAdjustmentFn = adjustRfc850Year;\n    } else {\n      match = ASC_TIME.exec(value);\n      if (match && match.groups) {\n        dayFn = (value) => parseDateValue(value.trimLeft(), \"day\", 1, 31);\n      } else {\n        throw new TypeError(\"Invalid RFC-7231 date-time value\");\n      }\n    }\n  }\n\n  const year = yearFn(match.groups[\"Y\"]);\n  const month = parseMonthByShortName(match.groups[\"M\"]);\n  const day = dayFn(match.groups[\"D\"]);\n  return dateAdjustmentFn(buildDate(year, month, day, match));\n};\n\n/**\n * Parses a value into a Date. Returns undefined if the input is null or\n * undefined, throws an error if the input is not a number or a parseable string.\n *\n * Input strings must be an integer or floating point number. Fractional seconds are supported.\n *\n * @param value the value to parse\n * @return a Date or undefined\n */\nexport const parseEpochTimestamp = (value: unknown): Date | undefined => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n\n  let valueAsDouble: number;\n  if (typeof value === \"number\") {\n    valueAsDouble = value;\n  } else if (typeof value === \"string\") {\n    valueAsDouble = strictParseDouble(value)!;\n  } else {\n    throw new TypeError(\"Epoch timestamps must be expressed as floating point numbers or their string representation\");\n  }\n\n  if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {\n    throw new TypeError(\"Epoch timestamps must be valid, non-Infinite, non-NaN numerics\");\n  }\n  return new Date(Math.round(valueAsDouble * 1000));\n};\n\n/**\n * Build a date from a numeric year, month, date, and an match with named groups\n * \"H\", \"m\", s\", and \"frac\", representing hours, minutes, seconds, and optional fractional seconds.\n * @param year numeric year\n * @param month numeric month, 1-indexed\n * @param day numeric year\n * @param match match with groups \"H\", \"m\", s\", and \"frac\"\n */\nconst buildDate = (year: number, month: number, day: number, match: RegExpMatchArray): Date => {\n  const adjustedMonth = month - 1; // JavaScript, and our internal data structures, expect 0-indexed months\n  validateDayOfMonth(year, adjustedMonth, day);\n  // Adjust month down by 1\n  return new Date(\n    Date.UTC(\n      year,\n      adjustedMonth,\n      day,\n      parseDateValue(match.groups![\"H\"]!, \"hour\", 0, 23),\n      parseDateValue(match.groups![\"m\"]!, \"minute\", 0, 59),\n      // seconds can go up to 60 for leap seconds\n      parseDateValue(match.groups![\"s\"]!, \"seconds\", 0, 60),\n      parseMilliseconds(match.groups![\"frac\"])\n    )\n  );\n};\n\n/**\n * RFC 850 dates use a 2-digit year; start with the assumption that if it doesn't\n * match the current year, then it's a date in the future, then let adjustRfc850Year adjust\n * the final date back to the past if it's too far in the future.\n *\n * Example: in 2021, start with the assumption that '11' is '2111', and that '22' is '2022'.\n * adjustRfc850Year will adjust '11' to 2011, (as 2111 is more than 50 years in the future),\n * but keep '22' as 2022. in 2099, '11' will represent '2111', but '98' should be '2098'.\n * There's no description of an RFC 850 date being considered too far in the past in RFC-7231,\n * so it's entirely possible that 2011 is a valid interpretation of '11' in 2099.\n * @param value the 2 digit year to parse\n * @return number a year that is equal to or greater than the current UTC year\n */\nconst parseTwoDigitYear = (value: string): number => {\n  const thisYear = new Date().getUTCFullYear();\n  const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value))!;\n  if (valueInThisCentury < thisYear) {\n    // This may end up returning a year that adjustRfc850Year turns back by 100.\n    // That's fine! We don't know the other components of the date yet, so there are\n    // boundary conditions that only adjustRfc850Year can handle.\n    return valueInThisCentury + 100;\n  }\n  return valueInThisCentury;\n};\n\nconst FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1000;\n\n/**\n * Adjusts the year value found in RFC 850 dates according to the rules\n * expressed in RFC7231, which state:\n *\n * <blockquote>Recipients of a timestamp value in rfc850-date format, which uses a\n * two-digit year, MUST interpret a timestamp that appears to be more\n * than 50 years in the future as representing the most recent year in\n * the past that had the same last two digits.</blockquote>\n *\n * @param input a Date that assumes the two-digit year was in the future\n * @return a Date that is in the past if input is > 50 years in the future\n */\nconst adjustRfc850Year = (input: Date): Date => {\n  if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {\n    return new Date(\n      Date.UTC(\n        input.getUTCFullYear() - 100,\n        input.getUTCMonth(),\n        input.getUTCDate(),\n        input.getUTCHours(),\n        input.getUTCMinutes(),\n        input.getUTCSeconds(),\n        input.getUTCMilliseconds()\n      )\n    );\n  }\n  return input;\n};\n\nconst parseMonthByShortName = (value: string): number => {\n  const monthIdx = MONTHS.indexOf(value);\n  if (monthIdx < 0) {\n    throw new TypeError(`Invalid month: ${value}`);\n  }\n  return monthIdx + 1;\n};\n\nconst DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n/**\n * Validate the day is valid for the given month.\n * @param year the year\n * @param month the month (0-indexed)\n * @param day the day of the month\n */\nconst validateDayOfMonth = (year: number, month: number, day: number) => {\n  let maxDays = DAYS_IN_MONTH[month];\n  if (month === 1 && isLeapYear(year)) {\n    maxDays = 29;\n  }\n\n  if (day > maxDays) {\n    throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);\n  }\n};\n\nconst isLeapYear = (year: number): boolean => {\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n};\n\nconst parseDateValue = (value: string, type: string, lower: number, upper: number): number => {\n  const dateVal = strictParseByte(stripLeadingZeroes(value))!;\n  if (dateVal < lower || dateVal > upper) {\n    throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);\n  }\n  return dateVal;\n};\n\nconst parseMilliseconds = (value: string | undefined): number => {\n  if (value === null || value === undefined) {\n    return 0;\n  }\n\n  return strictParseFloat32(\"0.\" + value)! * 1000;\n};\n\nconst stripLeadingZeroes = (value: string): string => {\n  let idx = 0;\n  while (idx < value.length - 1 && value.charAt(idx) === \"0\") {\n    idx++;\n  }\n  if (idx === 0) {\n    return value;\n  }\n  return value.slice(idx);\n};\n"]},"metadata":{},"sourceType":"module"}