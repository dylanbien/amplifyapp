{"ast":null,"code":"import { __read } from \"tslib\";\n/**\n * Give an input string, strictly parses a boolean value.\n *\n * @param value The boolean string to parse.\n * @returns true for \"true\", false for \"false\", otherwise an error is thrown.\n */\n\nexport var parseBoolean = function (value) {\n  switch (value) {\n    case \"true\":\n      return true;\n\n    case \"false\":\n      return false;\n\n    default:\n      throw new Error(\"Unable to parse boolean value \\\"\" + value + \"\\\"\");\n  }\n};\n/*\n * Asserts a value is a boolean and returns it.\n *\n * @param value A value that is expected to be a boolean.\n * @returns The value if it's a boolean, undefined if it's null/undefined,\n *   otherwise an error is thrown.\n */\n\nexport var expectBoolean = function (value) {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n\n  throw new TypeError(\"Expected boolean, got \" + typeof value);\n};\n/**\n * Asserts a value is a number and returns it.\n *\n * @param value A value that is expected to be a number.\n * @returns The value if it's a number, undefined if it's null/undefined,\n *   otherwise an error is thrown.\n */\n\nexport var expectNumber = function (value) {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n\n  if (typeof value === \"number\") {\n    return value;\n  }\n\n  throw new TypeError(\"Expected number, got \" + typeof value);\n};\nvar MAX_FLOAT = Math.ceil(Math.pow(2, 127) * (2 - Math.pow(2, -23)));\n/**\n * Asserts a value is a 32-bit float and returns it.\n *\n * @param value A value that is expected to be a 32-bit float.\n * @returns The value if it's a float, undefined if it's null/undefined,\n *   otherwise an error is thrown.\n */\n\nexport var expectFloat32 = function (value) {\n  var expected = expectNumber(value);\n\n  if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {\n    // IEEE-754 is an imperfect representation for floats. Consider the simple\n    // value `0.1`. The representation in a 32-bit float would look like:\n    //\n    // 0 01111011 10011001100110011001101\n    // Actual value: 0.100000001490116119384765625\n    //\n    // Note the repeating pattern of `1001` in the fraction part. The 64-bit\n    // representation is similar:\n    //\n    // 0 01111111011 1001100110011001100110011001100110011001100110011010\n    // Actual value: 0.100000000000000005551115123126\n    //\n    // So even for what we consider simple numbers, the representation differs\n    // between the two formats. And it's non-obvious how one might look at the\n    // 64-bit value (which is how JS represents numbers) and determine if it\n    // can be represented reasonably in the 32-bit form. Primarily because you\n    // can't know whether the intent was to represent `0.1` or the actual\n    // value in memory. But even if you have both the decimal value and the\n    // double value, that still doesn't communicate the intended precision.\n    //\n    // So rather than attempting to divine the intent of the caller, we instead\n    // do some simple bounds checking to make sure the value is passingly\n    // representable in a 32-bit float. It's not perfect, but it's good enough.\n    // Perfect, even if possible to achieve, would likely be too costly to\n    // be worth it.\n    //\n    // The maximum value of a 32-bit float. Since the 64-bit representation\n    // could be more or less, we just round it up to the nearest whole number.\n    // This further reduces our ability to be certain of the value, but it's\n    // an acceptable tradeoff.\n    //\n    // Compare against the absolute value to simplify things.\n    if (Math.abs(expected) > MAX_FLOAT) {\n      throw new TypeError(\"Expected 32-bit float, got \" + value);\n    }\n  }\n\n  return expected;\n};\n/**\n * Asserts a value is an integer and returns it.\n *\n * @param value A value that is expected to be an integer.\n * @returns The value if it's an integer, undefined if it's null/undefined,\n *   otherwise an error is thrown.\n */\n\nexport var expectLong = function (value) {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n\n  if (Number.isInteger(value) && !Number.isNaN(value)) {\n    return value;\n  }\n\n  throw new TypeError(\"Expected integer, got \" + typeof value);\n};\n/**\n * @deprecated Use expectLong\n */\n\nexport var expectInt = expectLong;\n/**\n * Asserts a value is a 32-bit integer and returns it.\n *\n * @param value A value that is expected to be an integer.\n * @returns The value if it's an integer, undefined if it's null/undefined,\n *   otherwise an error is thrown.\n */\n\nexport var expectInt32 = function (value) {\n  return expectSizedInt(value, 32);\n};\n/**\n * Asserts a value is a 16-bit integer and returns it.\n *\n * @param value A value that is expected to be an integer.\n * @returns The value if it's an integer, undefined if it's null/undefined,\n *   otherwise an error is thrown.\n */\n\nexport var expectShort = function (value) {\n  return expectSizedInt(value, 16);\n};\n/**\n * Asserts a value is an 8-bit integer and returns it.\n *\n * @param value A value that is expected to be an integer.\n * @returns The value if it's an integer, undefined if it's null/undefined,\n *   otherwise an error is thrown.\n */\n\nexport var expectByte = function (value) {\n  return expectSizedInt(value, 8);\n};\n\nvar expectSizedInt = function (value, size) {\n  var expected = expectLong(value);\n\n  if (expected !== undefined && castInt(expected, size) !== expected) {\n    throw new TypeError(\"Expected \" + size + \"-bit integer, got \" + value);\n  }\n\n  return expected;\n};\n\nvar castInt = function (value, size) {\n  switch (size) {\n    case 32:\n      return Int32Array.of(value)[0];\n\n    case 16:\n      return Int16Array.of(value)[0];\n\n    case 8:\n      return Int8Array.of(value)[0];\n  }\n};\n/**\n * Asserts a value is not null or undefined and returns it, or throws an error.\n *\n * @param value A value that is expected to be defined\n * @param location The location where we're expecting to find a defined object (optional)\n * @returns The value if it's not undefined, otherwise throws an error\n */\n\n\nexport var expectNonNull = function (value, location) {\n  if (value === null || value === undefined) {\n    if (location) {\n      throw new TypeError(\"Expected a non-null value for \" + location);\n    }\n\n    throw new TypeError(\"Expected a non-null value\");\n  }\n\n  return value;\n};\n/**\n * Asserts a value is an JSON-like object and returns it. This is expected to be used\n * with values parsed from JSON (arrays, objects, numbers, strings, booleans).\n *\n * @param value A value that is expected to be an object\n * @returns The value if it's an object, undefined if it's null/undefined,\n *   otherwise an error is thrown.\n */\n\nexport var expectObject = function (value) {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n\n  if (typeof value === \"object\" && !Array.isArray(value)) {\n    return value;\n  }\n\n  throw new TypeError(\"Expected object, got \" + typeof value);\n};\n/**\n * Asserts a value is a string and returns it.\n *\n * @param value A value that is expected to be a string.\n * @returns The value if it's a string, undefined if it's null/undefined,\n *   otherwise an error is thrown.\n */\n\nexport var expectString = function (value) {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n\n  if (typeof value === \"string\") {\n    return value;\n  }\n\n  throw new TypeError(\"Expected string, got \" + typeof value);\n};\n/**\n * Asserts a value is a JSON-like object with only one non-null/non-undefined key and\n * returns it.\n *\n * @param value A value that is expected to be an object with exactly one non-null,\n *              non-undefined key.\n * @return the value if it's a union, undefined if it's null/undefined, otherwise\n *  an error is thrown.\n */\n\nexport var expectUnion = function (value) {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n\n  var asObject = expectObject(value);\n  var setKeys = Object.entries(asObject).filter(function (_a) {\n    var _b = __read(_a, 2),\n        _ = _b[0],\n        v = _b[1];\n\n    return v !== null && v !== undefined;\n  }).map(function (_a) {\n    var _b = __read(_a, 2),\n        k = _b[0],\n        _ = _b[1];\n\n    return k;\n  });\n\n  if (setKeys.length === 0) {\n    throw new TypeError(\"Unions must have exactly one non-null member\");\n  }\n\n  if (setKeys.length > 1) {\n    throw new TypeError(\"Unions must have exactly one non-null member. Keys \" + setKeys + \" were not null.\");\n  }\n\n  return asObject;\n};\n/**\n * Parses a value into a double. If the value is null or undefined, undefined\n * will be returned. If the value is a string, it will be parsed by the standard\n * parseFloat with one exception: NaN may only be explicitly set as the string\n * \"NaN\", any implicit Nan values will result in an error being thrown. If any\n * other type is provided, an exception will be thrown.\n *\n * @param value A number or string representation of a double.\n * @returns The value as a number, or undefined if it's null/undefined.\n */\n\nexport var strictParseDouble = function (value) {\n  if (typeof value == \"string\") {\n    return expectNumber(parseNumber(value));\n  }\n\n  return expectNumber(value);\n};\n/**\n * @deprecated Use strictParseDouble\n */\n\nexport var strictParseFloat = strictParseDouble;\n/**\n * Parses a value into a float. If the value is null or undefined, undefined\n * will be returned. If the value is a string, it will be parsed by the standard\n * parseFloat with one exception: NaN may only be explicitly set as the string\n * \"NaN\", any implicit Nan values will result in an error being thrown. If any\n * other type is provided, an exception will be thrown.\n *\n * @param value A number or string representation of a float.\n * @returns The value as a number, or undefined if it's null/undefined.\n */\n\nexport var strictParseFloat32 = function (value) {\n  if (typeof value == \"string\") {\n    return expectFloat32(parseNumber(value));\n  }\n\n  return expectFloat32(value);\n}; // This regex matches JSON-style numbers. In short:\n// * The integral may start with a negative sign, but not a positive one\n// * No leading 0 on the integral unless it's immediately followed by a '.'\n// * Exponent indicated by a case-insensitive 'E' optionally followed by a\n//   positive/negative sign and some number of digits.\n// It also matches both positive and negative infinity as well and explicit NaN.\n\nvar NUMBER_REGEX = /(-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)|(-?Infinity)|(NaN)/g;\n\nvar parseNumber = function (value) {\n  var matches = value.match(NUMBER_REGEX);\n\n  if (matches === null || matches[0].length !== value.length) {\n    throw new TypeError(\"Expected real number, got implicit NaN\");\n  }\n\n  return parseFloat(value);\n};\n/**\n * Asserts a value is a number and returns it. If the value is a string\n * representation of a non-numeric number type (NaN, Infinity, -Infinity),\n * the value will be parsed. Any other string value will result in an exception\n * being thrown. Null or undefined will be returned as undefined. Any other\n * type will result in an exception being thrown.\n *\n * @param value A number or string representation of a non-numeric float.\n * @returns The value as a number, or undefined if it's null/undefined.\n */\n\n\nexport var limitedParseDouble = function (value) {\n  if (typeof value == \"string\") {\n    return parseFloatString(value);\n  }\n\n  return expectNumber(value);\n};\n/**\n * @deprecated Use limitedParseDouble\n */\n\nexport var handleFloat = limitedParseDouble;\n/**\n * @deprecated Use limitedParseDouble\n */\n\nexport var limitedParseFloat = limitedParseDouble;\n/**\n * Asserts a value is a 32-bit float and returns it. If the value is a string\n * representation of a non-numeric number type (NaN, Infinity, -Infinity),\n * the value will be parsed. Any other string value will result in an exception\n * being thrown. Null or undefined will be returned as undefined. Any other\n * type will result in an exception being thrown.\n *\n * @param value A number or string representation of a non-numeric float.\n * @returns The value as a number, or undefined if it's null/undefined.\n */\n\nexport var limitedParseFloat32 = function (value) {\n  if (typeof value == \"string\") {\n    return parseFloatString(value);\n  }\n\n  return expectFloat32(value);\n};\n\nvar parseFloatString = function (value) {\n  switch (value) {\n    case \"NaN\":\n      return NaN;\n\n    case \"Infinity\":\n      return Infinity;\n\n    case \"-Infinity\":\n      return -Infinity;\n\n    default:\n      throw new Error(\"Unable to parse float value: \" + value);\n  }\n};\n/**\n * Parses a value into an integer. If the value is null or undefined, undefined\n * will be returned. If the value is a string, it will be parsed by parseFloat\n * and the result will be asserted to be an integer. If the parsed value is not\n * an integer, or the raw value is any type other than a string or number, an\n * exception will be thrown.\n *\n * @param value A number or string representation of an integer.\n * @returns The value as a number, or undefined if it's null/undefined.\n */\n\n\nexport var strictParseLong = function (value) {\n  if (typeof value === \"string\") {\n    // parseInt can't be used here, because it will silently discard any\n    // existing decimals. We want to instead throw an error if there are any.\n    return expectLong(parseNumber(value));\n  }\n\n  return expectLong(value);\n};\n/**\n * @deprecated Use strictParseLong\n */\n\nexport var strictParseInt = strictParseLong;\n/**\n * Parses a value into a 32-bit integer. If the value is null or undefined, undefined\n * will be returned. If the value is a string, it will be parsed by parseFloat\n * and the result will be asserted to be an integer. If the parsed value is not\n * an integer, or the raw value is any type other than a string or number, an\n * exception will be thrown.\n *\n * @param value A number or string representation of a 32-bit integer.\n * @returns The value as a number, or undefined if it's null/undefined.\n */\n\nexport var strictParseInt32 = function (value) {\n  if (typeof value === \"string\") {\n    // parseInt can't be used here, because it will silently discard any\n    // existing decimals. We want to instead throw an error if there are any.\n    return expectInt32(parseNumber(value));\n  }\n\n  return expectInt32(value);\n};\n/**\n * Parses a value into a 16-bit integer. If the value is null or undefined, undefined\n * will be returned. If the value is a string, it will be parsed by parseFloat\n * and the result will be asserted to be an integer. If the parsed value is not\n * an integer, or the raw value is any type other than a string or number, an\n * exception will be thrown.\n *\n * @param value A number or string representation of a 16-bit integer.\n * @returns The value as a number, or undefined if it's null/undefined.\n */\n\nexport var strictParseShort = function (value) {\n  if (typeof value === \"string\") {\n    // parseInt can't be used here, because it will silently discard any\n    // existing decimals. We want to instead throw an error if there are any.\n    return expectShort(parseNumber(value));\n  }\n\n  return expectShort(value);\n};\n/**\n * Parses a value into an 8-bit integer. If the value is null or undefined, undefined\n * will be returned. If the value is a string, it will be parsed by parseFloat\n * and the result will be asserted to be an integer. If the parsed value is not\n * an integer, or the raw value is any type other than a string or number, an\n * exception will be thrown.\n *\n * @param value A number or string representation of an 8-bit integer.\n * @returns The value as a number, or undefined if it's null/undefined.\n */\n\nexport var strictParseByte = function (value) {\n  if (typeof value === \"string\") {\n    // parseInt can't be used here, because it will silently discard any\n    // existing decimals. We want to instead throw an error if there are any.\n    return expectByte(parseNumber(value));\n  }\n\n  return expectByte(value);\n};","map":{"version":3,"mappings":"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","names":["parseBoolean","value","Error","expectBoolean","undefined","TypeError","expectNumber","MAX_FLOAT","Math","ceil","expectFloat32","expected","Number","isNaN","Infinity","abs","expectLong","isInteger","expectInt","expectInt32","expectShort","expectByte","expectSizedInt","size","castInt","Int32Array","of","Int16Array","Int8Array","expectNonNull","location","expectObject","Array","isArray","expectString","expectUnion","asObject","setKeys","Object","entries","filter","_a","_b","_","v","map","k","length","strictParseDouble","parseNumber","strictParseFloat","strictParseFloat32","NUMBER_REGEX","matches","match","parseFloat","limitedParseDouble","parseFloatString","handleFloat","limitedParseFloat","limitedParseFloat32","NaN","strictParseLong","strictParseInt","strictParseInt32","strictParseShort","strictParseByte"],"sources":["/Users/dylanbienstock/Documents/cs98/hack-a-thing-1/amplifyapp/node_modules/@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/smithy-client/src/parse-utils.ts"],"sourcesContent":["/**\n * Give an input string, strictly parses a boolean value.\n *\n * @param value The boolean string to parse.\n * @returns true for \"true\", false for \"false\", otherwise an error is thrown.\n */\nexport const parseBoolean = (value: string): boolean => {\n  switch (value) {\n    case \"true\":\n      return true;\n    case \"false\":\n      return false;\n    default:\n      throw new Error(`Unable to parse boolean value \"${value}\"`);\n  }\n};\n\n/*\n * Asserts a value is a boolean and returns it.\n *\n * @param value A value that is expected to be a boolean.\n * @returns The value if it's a boolean, undefined if it's null/undefined,\n *   otherwise an error is thrown.\n */\nexport const expectBoolean = (value: any): boolean | undefined => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  throw new TypeError(`Expected boolean, got ${typeof value}`);\n};\n\n/**\n * Asserts a value is a number and returns it.\n *\n * @param value A value that is expected to be a number.\n * @returns The value if it's a number, undefined if it's null/undefined,\n *   otherwise an error is thrown.\n */\nexport const expectNumber = (value: any): number | undefined => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (typeof value === \"number\") {\n    return value;\n  }\n  throw new TypeError(`Expected number, got ${typeof value}`);\n};\n\nconst MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));\n\n/**\n * Asserts a value is a 32-bit float and returns it.\n *\n * @param value A value that is expected to be a 32-bit float.\n * @returns The value if it's a float, undefined if it's null/undefined,\n *   otherwise an error is thrown.\n */\nexport const expectFloat32 = (value: any): number | undefined => {\n  const expected = expectNumber(value);\n  if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {\n    // IEEE-754 is an imperfect representation for floats. Consider the simple\n    // value `0.1`. The representation in a 32-bit float would look like:\n    //\n    // 0 01111011 10011001100110011001101\n    // Actual value: 0.100000001490116119384765625\n    //\n    // Note the repeating pattern of `1001` in the fraction part. The 64-bit\n    // representation is similar:\n    //\n    // 0 01111111011 1001100110011001100110011001100110011001100110011010\n    // Actual value: 0.100000000000000005551115123126\n    //\n    // So even for what we consider simple numbers, the representation differs\n    // between the two formats. And it's non-obvious how one might look at the\n    // 64-bit value (which is how JS represents numbers) and determine if it\n    // can be represented reasonably in the 32-bit form. Primarily because you\n    // can't know whether the intent was to represent `0.1` or the actual\n    // value in memory. But even if you have both the decimal value and the\n    // double value, that still doesn't communicate the intended precision.\n    //\n    // So rather than attempting to divine the intent of the caller, we instead\n    // do some simple bounds checking to make sure the value is passingly\n    // representable in a 32-bit float. It's not perfect, but it's good enough.\n    // Perfect, even if possible to achieve, would likely be too costly to\n    // be worth it.\n    //\n    // The maximum value of a 32-bit float. Since the 64-bit representation\n    // could be more or less, we just round it up to the nearest whole number.\n    // This further reduces our ability to be certain of the value, but it's\n    // an acceptable tradeoff.\n    //\n    // Compare against the absolute value to simplify things.\n    if (Math.abs(expected) > MAX_FLOAT) {\n      throw new TypeError(`Expected 32-bit float, got ${value}`);\n    }\n  }\n  return expected;\n};\n\n/**\n * Asserts a value is an integer and returns it.\n *\n * @param value A value that is expected to be an integer.\n * @returns The value if it's an integer, undefined if it's null/undefined,\n *   otherwise an error is thrown.\n */\nexport const expectLong = (value: any): number | undefined => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (Number.isInteger(value) && !Number.isNaN(value)) {\n    return value;\n  }\n  throw new TypeError(`Expected integer, got ${typeof value}`);\n};\n\n/**\n * @deprecated Use expectLong\n */\nexport const expectInt = expectLong;\n\n/**\n * Asserts a value is a 32-bit integer and returns it.\n *\n * @param value A value that is expected to be an integer.\n * @returns The value if it's an integer, undefined if it's null/undefined,\n *   otherwise an error is thrown.\n */\nexport const expectInt32 = (value: any): number | undefined => expectSizedInt(value, 32);\n\n/**\n * Asserts a value is a 16-bit integer and returns it.\n *\n * @param value A value that is expected to be an integer.\n * @returns The value if it's an integer, undefined if it's null/undefined,\n *   otherwise an error is thrown.\n */\nexport const expectShort = (value: any): number | undefined => expectSizedInt(value, 16);\n\n/**\n * Asserts a value is an 8-bit integer and returns it.\n *\n * @param value A value that is expected to be an integer.\n * @returns The value if it's an integer, undefined if it's null/undefined,\n *   otherwise an error is thrown.\n */\nexport const expectByte = (value: any): number | undefined => expectSizedInt(value, 8);\n\ntype IntSize = 32 | 16 | 8;\n\nconst expectSizedInt = (value: any, size: IntSize): number | undefined => {\n  const expected = expectLong(value);\n  if (expected !== undefined && castInt(expected, size) !== expected) {\n    throw new TypeError(`Expected ${size}-bit integer, got ${value}`);\n  }\n  return expected;\n};\n\nconst castInt = (value: number, size: IntSize) => {\n  switch (size) {\n    case 32:\n      return Int32Array.of(value)[0];\n    case 16:\n      return Int16Array.of(value)[0];\n    case 8:\n      return Int8Array.of(value)[0];\n  }\n};\n\n/**\n * Asserts a value is not null or undefined and returns it, or throws an error.\n *\n * @param value A value that is expected to be defined\n * @param location The location where we're expecting to find a defined object (optional)\n * @returns The value if it's not undefined, otherwise throws an error\n */\nexport const expectNonNull = <T>(value: T | null | undefined, location?: string): T => {\n  if (value === null || value === undefined) {\n    if (location) {\n      throw new TypeError(`Expected a non-null value for ${location}`);\n    }\n    throw new TypeError(\"Expected a non-null value\");\n  }\n  return value;\n};\n\n/**\n * Asserts a value is an JSON-like object and returns it. This is expected to be used\n * with values parsed from JSON (arrays, objects, numbers, strings, booleans).\n *\n * @param value A value that is expected to be an object\n * @returns The value if it's an object, undefined if it's null/undefined,\n *   otherwise an error is thrown.\n */\nexport const expectObject = (value: any): { [key: string]: any } | undefined => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (typeof value === \"object\" && !Array.isArray(value)) {\n    return value;\n  }\n  throw new TypeError(`Expected object, got ${typeof value}`);\n};\n\n/**\n * Asserts a value is a string and returns it.\n *\n * @param value A value that is expected to be a string.\n * @returns The value if it's a string, undefined if it's null/undefined,\n *   otherwise an error is thrown.\n */\nexport const expectString = (value: any): string | undefined => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  throw new TypeError(`Expected string, got ${typeof value}`);\n};\n\n/**\n * Asserts a value is a JSON-like object with only one non-null/non-undefined key and\n * returns it.\n *\n * @param value A value that is expected to be an object with exactly one non-null,\n *              non-undefined key.\n * @return the value if it's a union, undefined if it's null/undefined, otherwise\n *  an error is thrown.\n */\nexport const expectUnion = (value: unknown): { [key: string]: any } | undefined => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  const asObject = expectObject(value)!;\n\n  const setKeys = Object.entries(asObject)\n    .filter(([_, v]) => v !== null && v !== undefined)\n    .map(([k, _]) => k);\n\n  if (setKeys.length === 0) {\n    throw new TypeError(`Unions must have exactly one non-null member`);\n  }\n\n  if (setKeys.length > 1) {\n    throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);\n  }\n\n  return asObject;\n};\n\n/**\n * Parses a value into a double. If the value is null or undefined, undefined\n * will be returned. If the value is a string, it will be parsed by the standard\n * parseFloat with one exception: NaN may only be explicitly set as the string\n * \"NaN\", any implicit Nan values will result in an error being thrown. If any\n * other type is provided, an exception will be thrown.\n *\n * @param value A number or string representation of a double.\n * @returns The value as a number, or undefined if it's null/undefined.\n */\nexport const strictParseDouble = (value: string | number): number | undefined => {\n  if (typeof value == \"string\") {\n    return expectNumber(parseNumber(value));\n  }\n  return expectNumber(value);\n};\n\n/**\n * @deprecated Use strictParseDouble\n */\nexport const strictParseFloat = strictParseDouble;\n\n/**\n * Parses a value into a float. If the value is null or undefined, undefined\n * will be returned. If the value is a string, it will be parsed by the standard\n * parseFloat with one exception: NaN may only be explicitly set as the string\n * \"NaN\", any implicit Nan values will result in an error being thrown. If any\n * other type is provided, an exception will be thrown.\n *\n * @param value A number or string representation of a float.\n * @returns The value as a number, or undefined if it's null/undefined.\n */\nexport const strictParseFloat32 = (value: string | number): number | undefined => {\n  if (typeof value == \"string\") {\n    return expectFloat32(parseNumber(value));\n  }\n  return expectFloat32(value);\n};\n\n// This regex matches JSON-style numbers. In short:\n// * The integral may start with a negative sign, but not a positive one\n// * No leading 0 on the integral unless it's immediately followed by a '.'\n// * Exponent indicated by a case-insensitive 'E' optionally followed by a\n//   positive/negative sign and some number of digits.\n// It also matches both positive and negative infinity as well and explicit NaN.\nconst NUMBER_REGEX = /(-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)|(-?Infinity)|(NaN)/g;\n\nconst parseNumber = (value: string): number => {\n  const matches = value.match(NUMBER_REGEX);\n  if (matches === null || matches[0].length !== value.length) {\n    throw new TypeError(`Expected real number, got implicit NaN`);\n  }\n  return parseFloat(value);\n};\n\n/**\n * Asserts a value is a number and returns it. If the value is a string\n * representation of a non-numeric number type (NaN, Infinity, -Infinity),\n * the value will be parsed. Any other string value will result in an exception\n * being thrown. Null or undefined will be returned as undefined. Any other\n * type will result in an exception being thrown.\n *\n * @param value A number or string representation of a non-numeric float.\n * @returns The value as a number, or undefined if it's null/undefined.\n */\nexport const limitedParseDouble = (value: string | number): number | undefined => {\n  if (typeof value == \"string\") {\n    return parseFloatString(value);\n  }\n  return expectNumber(value);\n};\n\n/**\n * @deprecated Use limitedParseDouble\n */\nexport const handleFloat = limitedParseDouble;\n\n/**\n * @deprecated Use limitedParseDouble\n */\nexport const limitedParseFloat = limitedParseDouble;\n\n/**\n * Asserts a value is a 32-bit float and returns it. If the value is a string\n * representation of a non-numeric number type (NaN, Infinity, -Infinity),\n * the value will be parsed. Any other string value will result in an exception\n * being thrown. Null or undefined will be returned as undefined. Any other\n * type will result in an exception being thrown.\n *\n * @param value A number or string representation of a non-numeric float.\n * @returns The value as a number, or undefined if it's null/undefined.\n */\nexport const limitedParseFloat32 = (value: string | number): number | undefined => {\n  if (typeof value == \"string\") {\n    return parseFloatString(value);\n  }\n  return expectFloat32(value);\n};\n\nconst parseFloatString = (value: string): number => {\n  switch (value) {\n    case \"NaN\":\n      return NaN;\n    case \"Infinity\":\n      return Infinity;\n    case \"-Infinity\":\n      return -Infinity;\n    default:\n      throw new Error(`Unable to parse float value: ${value}`);\n  }\n};\n\n/**\n * Parses a value into an integer. If the value is null or undefined, undefined\n * will be returned. If the value is a string, it will be parsed by parseFloat\n * and the result will be asserted to be an integer. If the parsed value is not\n * an integer, or the raw value is any type other than a string or number, an\n * exception will be thrown.\n *\n * @param value A number or string representation of an integer.\n * @returns The value as a number, or undefined if it's null/undefined.\n */\nexport const strictParseLong = (value: string | number): number | undefined => {\n  if (typeof value === \"string\") {\n    // parseInt can't be used here, because it will silently discard any\n    // existing decimals. We want to instead throw an error if there are any.\n    return expectLong(parseNumber(value));\n  }\n  return expectLong(value);\n};\n\n/**\n * @deprecated Use strictParseLong\n */\nexport const strictParseInt = strictParseLong;\n\n/**\n * Parses a value into a 32-bit integer. If the value is null or undefined, undefined\n * will be returned. If the value is a string, it will be parsed by parseFloat\n * and the result will be asserted to be an integer. If the parsed value is not\n * an integer, or the raw value is any type other than a string or number, an\n * exception will be thrown.\n *\n * @param value A number or string representation of a 32-bit integer.\n * @returns The value as a number, or undefined if it's null/undefined.\n */\nexport const strictParseInt32 = (value: string | number): number | undefined => {\n  if (typeof value === \"string\") {\n    // parseInt can't be used here, because it will silently discard any\n    // existing decimals. We want to instead throw an error if there are any.\n    return expectInt32(parseNumber(value));\n  }\n  return expectInt32(value);\n};\n\n/**\n * Parses a value into a 16-bit integer. If the value is null or undefined, undefined\n * will be returned. If the value is a string, it will be parsed by parseFloat\n * and the result will be asserted to be an integer. If the parsed value is not\n * an integer, or the raw value is any type other than a string or number, an\n * exception will be thrown.\n *\n * @param value A number or string representation of a 16-bit integer.\n * @returns The value as a number, or undefined if it's null/undefined.\n */\nexport const strictParseShort = (value: string | number): number | undefined => {\n  if (typeof value === \"string\") {\n    // parseInt can't be used here, because it will silently discard any\n    // existing decimals. We want to instead throw an error if there are any.\n    return expectShort(parseNumber(value));\n  }\n  return expectShort(value);\n};\n\n/**\n * Parses a value into an 8-bit integer. If the value is null or undefined, undefined\n * will be returned. If the value is a string, it will be parsed by parseFloat\n * and the result will be asserted to be an integer. If the parsed value is not\n * an integer, or the raw value is any type other than a string or number, an\n * exception will be thrown.\n *\n * @param value A number or string representation of an 8-bit integer.\n * @returns The value as a number, or undefined if it's null/undefined.\n */\nexport const strictParseByte = (value: string | number): number | undefined => {\n  if (typeof value === \"string\") {\n    // parseInt can't be used here, because it will silently discard any\n    // existing decimals. We want to instead throw an error if there are any.\n    return expectByte(parseNumber(value));\n  }\n  return expectByte(value);\n};\n"]},"metadata":{},"sourceType":"module"}