{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { isThrottlingError } from \"@aws-sdk/service-error-classification\";\n\nvar DefaultRateLimiter =\n/** @class */\nfunction () {\n  function DefaultRateLimiter(options) {\n    var _a, _b, _c, _d, _e; // Pre-set state variables\n\n\n    this.currentCapacity = 0;\n    this.enabled = false;\n    this.lastMaxRate = 0;\n    this.measuredTxRate = 0;\n    this.requestCount = 0;\n    this.lastTimestamp = 0;\n    this.timeWindow = 0;\n    this.beta = (_a = options === null || options === void 0 ? void 0 : options.beta) !== null && _a !== void 0 ? _a : 0.7;\n    this.minCapacity = (_b = options === null || options === void 0 ? void 0 : options.minCapacity) !== null && _b !== void 0 ? _b : 1;\n    this.minFillRate = (_c = options === null || options === void 0 ? void 0 : options.minFillRate) !== null && _c !== void 0 ? _c : 0.5;\n    this.scaleConstant = (_d = options === null || options === void 0 ? void 0 : options.scaleConstant) !== null && _d !== void 0 ? _d : 0.4;\n    this.smooth = (_e = options === null || options === void 0 ? void 0 : options.smooth) !== null && _e !== void 0 ? _e : 0.8;\n    var currentTimeInSeconds = this.getCurrentTimeInSeconds();\n    this.lastThrottleTime = currentTimeInSeconds;\n    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());\n    this.fillRate = this.minFillRate;\n    this.maxCapacity = this.minCapacity;\n  }\n\n  DefaultRateLimiter.prototype.getCurrentTimeInSeconds = function () {\n    return Date.now() / 1000;\n  };\n\n  DefaultRateLimiter.prototype.getSendToken = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.acquireTokenBucket(1)];\n      });\n    });\n  };\n\n  DefaultRateLimiter.prototype.acquireTokenBucket = function (amount) {\n    return __awaiter(this, void 0, void 0, function () {\n      var delay_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // Client side throttling is not enabled until we see a throttling error.\n            if (!this.enabled) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            this.refillTokenBucket();\n            if (!(amount > this.currentCapacity)) return [3\n            /*break*/\n            , 2];\n            delay_1 = (amount - this.currentCapacity) / this.fillRate * 1000;\n            return [4\n            /*yield*/\n            , new Promise(function (resolve) {\n              return setTimeout(resolve, delay_1);\n            })];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            this.currentCapacity = this.currentCapacity - amount;\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  DefaultRateLimiter.prototype.refillTokenBucket = function () {\n    var timestamp = this.getCurrentTimeInSeconds();\n\n    if (!this.lastTimestamp) {\n      this.lastTimestamp = timestamp;\n      return;\n    }\n\n    var fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;\n    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);\n    this.lastTimestamp = timestamp;\n  };\n\n  DefaultRateLimiter.prototype.updateClientSendingRate = function (response) {\n    var calculatedRate;\n    this.updateMeasuredRate();\n\n    if (isThrottlingError(response)) {\n      var rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);\n      this.lastMaxRate = rateToUse;\n      this.calculateTimeWindow();\n      this.lastThrottleTime = this.getCurrentTimeInSeconds();\n      calculatedRate = this.cubicThrottle(rateToUse);\n      this.enableTokenBucket();\n    } else {\n      this.calculateTimeWindow();\n      calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());\n    }\n\n    var newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);\n    this.updateTokenBucketRate(newRate);\n  };\n\n  DefaultRateLimiter.prototype.calculateTimeWindow = function () {\n    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));\n  };\n\n  DefaultRateLimiter.prototype.cubicThrottle = function (rateToUse) {\n    return this.getPrecise(rateToUse * this.beta);\n  };\n\n  DefaultRateLimiter.prototype.cubicSuccess = function (timestamp) {\n    return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);\n  };\n\n  DefaultRateLimiter.prototype.enableTokenBucket = function () {\n    this.enabled = true;\n  };\n\n  DefaultRateLimiter.prototype.updateTokenBucketRate = function (newRate) {\n    // Refill based on our current rate before we update to the new fill rate.\n    this.refillTokenBucket();\n    this.fillRate = Math.max(newRate, this.minFillRate);\n    this.maxCapacity = Math.max(newRate, this.minCapacity); // When we scale down we can't have a current capacity that exceeds our maxCapacity.\n\n    this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);\n  };\n\n  DefaultRateLimiter.prototype.updateMeasuredRate = function () {\n    var t = this.getCurrentTimeInSeconds();\n    var timeBucket = Math.floor(t * 2) / 2;\n    this.requestCount++;\n\n    if (timeBucket > this.lastTxRateBucket) {\n      var currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);\n      this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));\n      this.requestCount = 0;\n      this.lastTxRateBucket = timeBucket;\n    }\n  };\n\n  DefaultRateLimiter.prototype.getPrecise = function (num) {\n    return parseFloat(num.toFixed(8));\n  };\n\n  return DefaultRateLimiter;\n}();\n\nexport { DefaultRateLimiter };","map":{"version":3,"mappings":"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","names":["isThrottlingError","options","beta","_a","minCapacity","_b","minFillRate","_c","scaleConstant","_d","smooth","_e","currentTimeInSeconds","getCurrentTimeInSeconds","lastThrottleTime","lastTxRateBucket","Math","floor","fillRate","maxCapacity","DefaultRateLimiter","Date","now","acquireTokenBucket","amount","enabled","refillTokenBucket","currentCapacity","delay_1","Promise","resolve","timestamp","lastTimestamp","fillAmount","min","response","calculatedRate","updateMeasuredRate","rateToUse","measuredTxRate","lastMaxRate","calculateTimeWindow","cubicThrottle","enableTokenBucket","cubicSuccess","newRate","updateTokenBucketRate","timeWindow","getPrecise","pow","max","t","timeBucket","requestCount","currentRate","num","parseFloat","toFixed"],"sources":["/Users/dylanbienstock/Documents/cs98/hack-a-thing-1/amplifyapp/node_modules/@aws-sdk/client-lex-runtime-v2/node_modules/@aws-sdk/middleware-retry/src/DefaultRateLimiter.ts"],"sourcesContent":["import { isThrottlingError } from \"@aws-sdk/service-error-classification\";\n\nimport { RateLimiter } from \"./types\";\n\nexport interface DefaultRateLimiterOptions {\n  beta?: number;\n  minCapacity?: number;\n  minFillRate?: number;\n  scaleConstant?: number;\n  smooth?: number;\n}\n\nexport class DefaultRateLimiter implements RateLimiter {\n  // User configurable constants\n  private beta: number;\n  private minCapacity: number;\n  private minFillRate: number;\n  private scaleConstant: number;\n  private smooth: number;\n\n  // Pre-set state variables\n  private currentCapacity = 0;\n  private enabled = false;\n  private lastMaxRate = 0;\n  private measuredTxRate = 0;\n  private requestCount = 0;\n\n  // Other state variables\n  private fillRate: number;\n  private lastThrottleTime: number;\n  private lastTimestamp = 0;\n  private lastTxRateBucket: number;\n  private maxCapacity: number;\n  private timeWindow = 0;\n\n  constructor(options?: DefaultRateLimiterOptions) {\n    this.beta = options?.beta ?? 0.7;\n    this.minCapacity = options?.minCapacity ?? 1;\n    this.minFillRate = options?.minFillRate ?? 0.5;\n    this.scaleConstant = options?.scaleConstant ?? 0.4;\n    this.smooth = options?.smooth ?? 0.8;\n\n    const currentTimeInSeconds = this.getCurrentTimeInSeconds();\n    this.lastThrottleTime = currentTimeInSeconds;\n    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());\n\n    this.fillRate = this.minFillRate;\n    this.maxCapacity = this.minCapacity;\n  }\n\n  private getCurrentTimeInSeconds() {\n    return Date.now() / 1000;\n  }\n\n  public async getSendToken() {\n    return this.acquireTokenBucket(1);\n  }\n\n  private async acquireTokenBucket(amount: number) {\n    // Client side throttling is not enabled until we see a throttling error.\n    if (!this.enabled) {\n      return;\n    }\n\n    this.refillTokenBucket();\n    if (amount > this.currentCapacity) {\n      const delay = ((amount - this.currentCapacity) / this.fillRate) * 1000;\n      await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n    this.currentCapacity = this.currentCapacity - amount;\n  }\n\n  private refillTokenBucket() {\n    const timestamp = this.getCurrentTimeInSeconds();\n    if (!this.lastTimestamp) {\n      this.lastTimestamp = timestamp;\n      return;\n    }\n\n    const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;\n    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);\n    this.lastTimestamp = timestamp;\n  }\n\n  public updateClientSendingRate(response: any) {\n    let calculatedRate: number;\n    this.updateMeasuredRate();\n\n    if (isThrottlingError(response)) {\n      const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);\n      this.lastMaxRate = rateToUse;\n      this.calculateTimeWindow();\n      this.lastThrottleTime = this.getCurrentTimeInSeconds();\n      calculatedRate = this.cubicThrottle(rateToUse);\n      this.enableTokenBucket();\n    } else {\n      this.calculateTimeWindow();\n      calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());\n    }\n\n    const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);\n    this.updateTokenBucketRate(newRate);\n  }\n\n  private calculateTimeWindow() {\n    this.timeWindow = this.getPrecise(Math.pow((this.lastMaxRate * (1 - this.beta)) / this.scaleConstant, 1 / 3));\n  }\n\n  private cubicThrottle(rateToUse: number) {\n    return this.getPrecise(rateToUse * this.beta);\n  }\n\n  private cubicSuccess(timestamp: number) {\n    return this.getPrecise(\n      this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate\n    );\n  }\n\n  private enableTokenBucket() {\n    this.enabled = true;\n  }\n\n  private updateTokenBucketRate(newRate: number) {\n    // Refill based on our current rate before we update to the new fill rate.\n    this.refillTokenBucket();\n\n    this.fillRate = Math.max(newRate, this.minFillRate);\n    this.maxCapacity = Math.max(newRate, this.minCapacity);\n\n    // When we scale down we can't have a current capacity that exceeds our maxCapacity.\n    this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);\n  }\n\n  private updateMeasuredRate() {\n    const t = this.getCurrentTimeInSeconds();\n    const timeBucket = Math.floor(t * 2) / 2;\n    this.requestCount++;\n\n    if (timeBucket > this.lastTxRateBucket) {\n      const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);\n      this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));\n      this.requestCount = 0;\n      this.lastTxRateBucket = timeBucket;\n    }\n  }\n\n  private getPrecise(num: number) {\n    return parseFloat(num.toFixed(8));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}